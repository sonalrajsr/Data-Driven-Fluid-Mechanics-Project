# -*- coding: utf-8 -*-
"""FM_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/140spEH7v8MfSEpeZAw5AcLhf8EmmT9xh
"""

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/drive')

"""# Some basic functions

**Function to plot Cumulative variance ratio**
"""

def plot_cumulative_variance_ratio(S, threshold=0.95):
    # explained variance ratio
    explained_variance_ratio = (S ** 2) / np.sum(S ** 2)

    # cumulative explained variance ratio
    cumulative_variance_ratio = np.cumsum(explained_variance_ratio)

    # Plotting cumulative explained variance ratio
    plt.plot(range(1, len(cumulative_variance_ratio) + 1), cumulative_variance_ratio, marker='o', linestyle='-')
    plt.xlabel('Number of Singular Values (k)')
    plt.ylabel('Cumulative Explained Variance Ratio')
    plt.title('Cumulative Explained Variance Ratio vs. Number of Singular Values')
    plt.grid(True)

    # smallest k that captures the 95%
    k_threshold = np.argmax(cumulative_variance_ratio >= threshold) + 1

    # Plot the arrow
    plt.scatter(k_threshold, threshold, color='red', label=f'{int(threshold*100)}% Threshold')
    plt.annotate(f'({k_threshold}, {threshold})', xy=(k_threshold, threshold), xytext=(k_threshold + 10, threshold - 0.05),
                 arrowprops=dict(facecolor='black', arrowstyle='->'),)

    plt.legend()
    plt.show()

    print(f"The smallest k that captures {int(threshold*100)}% of the total variance: {k_threshold}")

    return k_threshold

"""**Function to plot energy contribution for first 10 modes**"""

def plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy):
    # % energy contribution by 10 modes
    percentage_energy_first_10_modes = (energy_first_10_modes / total_energy) * 100
    nonzero_indices = np.nonzero(percentage_energy_first_10_modes)
    percentage_energy_first_10_modes = percentage_energy_first_10_modes[nonzero_indices]

    # Plotting each value of enregy for 10 modes.
    plt.figure(figsize=(10, 6))
    plt.plot(range(1, len(percentage_energy_first_10_modes) + 1), percentage_energy_first_10_modes, marker='o', color='red', linestyle='-')
    plt.xlabel('Mode')
    plt.ylabel('Percentage of Total Energy')
    plt.title('Energy Contribution of First 10 Modes')
    plt.xticks(range(1, len(percentage_energy_first_10_modes) + 1))
    plt.grid(True)

    for i, (x, y) in enumerate(zip(range(1, len(percentage_energy_first_10_modes) + 1), percentage_energy_first_10_modes)):
        plt.text(x, y, f'({x},{y:.2f})', ha='right')

    plt.show()

"""**Function for loading and stacking of images**"""

def load_and_preprocess_images(folder_path):
    images = []
    for filename in sorted(os.listdir(folder_path)):
        if filename.endswith(".jpg"):
            image_path = os.path.join(folder_path, filename)
            image = cv2.imread(image_path)
            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            images.append(image)
    return images

def stack_images(images):
    stacked_images = np.array([image.flatten() for image in images])
    return stacked_images

"""#3.1 Image Generation"""

# video file path
video_path = "/content/drive/MyDrive/3CYL_Flow.mp4"
cap = cv2.VideoCapture(video_path)

# directory to save the frames
output_dir = "frames"
os.makedirs(output_dir, exist_ok=True)

# saving every 10th frames
frame_count = 0
saved_frame_count = 0
plt.figure(figsize=(15, 3))
while(cap.isOpened()):
    ret, frame = cap.read()
    if ret == False:
        break
    frame_count += 1
    if frame_count % 10 == 0:  # 10th frame
        saved_frame_count += 1
        frame_filename = os.path.join(output_dir, f"frame_{saved_frame_count:04d}.jpg")
        cv2.imwrite(frame_filename, frame)
        # printing some frames
        if saved_frame_count <= 5:
            plt.subplot(1, 5, saved_frame_count)
            plt.imshow(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
            plt.title(f"Frame {saved_frame_count}")
            plt.axis("off")

cap.release()

print(f"Total frames extracted: {saved_frame_count}")

plt.show()

def preprocess_image(image):
    grayscale_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    blurred_image = cv2.GaussianBlur(grayscale_image, (5, 5), 0)  # Specify kernel size

    return blurred_image

input_dir = "/content/frames"
output_dir = "processed_frames"
os.makedirs(output_dir, exist_ok=True)

image_files = sorted(os.listdir(input_dir), key=lambda x: int(x.split('_')[1].split('.')[0]))
for filename in image_files:
    if filename.endswith(".jpg"):
        image_path = os.path.join(input_dir, filename)

        frame = cv2.imread(image_path)

        processed_frame = preprocess_image(frame)

        output_path = os.path.join(output_dir, filename)
        cv2.imwrite(output_path, processed_frame)

sample_images = os.listdir(output_dir)[:5]
plt.figure(figsize=(15, 3))
for i, filename in enumerate(sample_images):
    image_path = os.path.join(output_dir, filename)
    image = cv2.imread(image_path)
    plt.subplot(1, 5, i+1)
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(f"Processed Frame {i+1}")
    plt.axis("off")

plt.show()

def enhance_image(image):
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    equalized_image = cv2.equalizeHist(gray_image)

    return equalized_image

input_dir = "/content/frames"
output_dir = "enhanced_frames"
os.makedirs(output_dir, exist_ok=True)

for filename in os.listdir(input_dir):
    if filename.endswith(".jpg"):
        image_path = os.path.join(input_dir, filename)
        frame = cv2.imread(image_path)

        enhanced_frame = enhance_image(frame)

        output_path = os.path.join(output_dir, filename)
        cv2.imwrite(output_path, enhanced_frame)

sample_images = os.listdir(output_dir)[:5]
plt.figure(figsize=(15, 3))
for i, filename in enumerate(sample_images):
    image_path = os.path.join(output_dir, filename)
    image = cv2.imread(image_path)
    plt.subplot(1, 5, i+1)
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title(f"Enhanced Frame {i+1}")
    plt.axis("off")

plt.show()

"""# Execute POD"""

# Folder containing the frames
folder_path = "/content/frames"

# Loading and preprocessing the images
images = load_and_preprocess_images(folder_path)
print("Image shape is (H, W)", images[0].shape)
images

# Stack images into a matrix
stacked_images = stack_images(images)
print(stacked_images)
print(f'Shape of stacked images matrix: {stacked_images.shape}')

# mean image
mean_image = np.mean(stacked_images, axis=0)
print(mean_image)
print("Mena image shape ",mean_image.shape)

# Reshaped to its original shape
mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image Reconstruction')
plt.axis('off')
plt.show()

# Subtract mean image from each image
mean_subtracted_images = stacked_images - mean_image
print(mean_subtracted_images)
print("Mean image shape",mean_subtracted_images.shape)

# Singular Value Decomposition
U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)
print(U)
print("spatial modes ",U.shape)
print(S)
print("singular values ",S.shape)
print(Vt)
print("temporal coefficients ",Vt.shape)

k_threshold = plot_cumulative_variance_ratio(S)

def reduce_dimensions(U, S, Vt, k):
    U_reduced = U[:, :k]
    print('Shape of U after dim reduction ',U_reduced.shape)
    S_reduced = np.diag(S[:k])
    print('Shape of S after dim reduction ',S_reduced.shape)
    Vt_reduced = Vt[:k, :]
    print('Shape of Vt after dim reduction ',Vt_reduced.shape)

    return U_reduced, S_reduced, Vt_reduced


U_reduced, S_reduced, Vt_reduced= reduce_dimensions(U, S, Vt, k_threshold)

reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image
print(reconstructed_images)
reconstructed_images.shape

"""# 3.3 Analyse POD Modes

*Here these 10 images are showing the top 10 flow mode which have the higheset energy among all the modes.
"""

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

"""*This is showing the total energy and percentage of total energy possesed by these 10 modes only.*"""

# Total Energy of all modes
total_energy = np.sum(S_reduced ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S_reduced[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

"""*Percentage of energy by each top 10 modes.*"""

# Individual energy of 10 modes
energy_first_10_modes = (S_reduced[:10] ** 2)
total_energy = np.sum(S_reduced ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    energy_contribution = ((energy / total_energy) * 100)[i-1]
    print(f"Energy contribution of mode {i}: {energy_contribution:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""# 4.1 Adding Noise

**Some basic functions to add noise**
"""

def add_gaussian_noise(image, magnitude):
    mean = 0
    std_dev = magnitude * 255 / 100
    noisy_image = image.copy()
    cv2.randn(noisy_image, mean, std_dev)
    noisy_image = cv2.add(image, noisy_image)
    return np.clip(noisy_image, 0, 255).astype(np.uint8)

def display_images(folder_path, image_prefix, num_images=5):
    plt.figure(figsize=(20, 3))
    for i in range(1, num_images+1):
        image_path = os.path.join(folder_path, f"{image_prefix}_{i:04d}.jpg")
        image = cv2.imread(image_path)
        plt.subplot(1, num_images, i)
        plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
        plt.title(f"Image {i}")
        plt.axis('off')
    plt.show()

def add_noise_to_frames(original_frames_folder, noise_folder, magnitude):

    os.makedirs(noise_folder, exist_ok=True)

    for filename in os.listdir(original_frames_folder):
        if filename.endswith(".jpg"):
            original_frame_path = os.path.join(original_frames_folder, filename)
            original_frame = cv2.imread(original_frame_path)

            noisy_frame = add_gaussian_noise(original_frame, magnitude) # gaussian noise

            noisy_frame_filename = f"noise_{magnitude}_{filename}"
            cv2.imwrite(os.path.join(noise_folder, noisy_frame_filename), noisy_frame)

    print(f"{magnitude}% Gaussian noise added to frames and saved in the '{noise_folder}' folder.")

"""# Adding Gaussian Noise

**Adding 20% noise**
"""

original_frames_folder = "/content/frames"
noise_folder = "/content/noise_20"
magnitude = 20

add_noise_to_frames(original_frames_folder, noise_folder, magnitude)

noisy_frames_folder = "/content/noise_20"
image_prefix = "noise_20_frame"

display_images(noisy_frames_folder, image_prefix)

"""**Adding 40% noise**"""

original_frames_folder = "/content/frames"
noise_folder = "/content/noise_40"
magnitude = 40

add_noise_to_frames(original_frames_folder, noise_folder, magnitude)

noisy_frames_folder = "/content/noise_40"
image_prefix = "noise_40_frame"

display_images(noisy_frames_folder, image_prefix)

"""**Adding 60% noise**"""

original_frames_folder = "/content/frames"
noise_folder = "/content/noise_60"
magnitude = 60

add_noise_to_frames(original_frames_folder, noise_folder, magnitude)

noisy_frames_folder = "/content/noise_60"
image_prefix = "noise_60_frame"

display_images(noisy_frames_folder, image_prefix)

"""**Adding 80% noise**"""

original_frames_folder = "/content/frames"
noise_folder = "/content/noise_80"
magnitude = 80

add_noise_to_frames(original_frames_folder, noise_folder, magnitude)

noisy_frames_folder = "/content/noise_80"
image_prefix = "noise_80_frame"

display_images(noisy_frames_folder, image_prefix)

"""# Adding speckle noise

*Some basic functions*
"""

def add_speckle_noise(image, magnitude):

    # standard deviation
    std_dev = magnitude * 255 / 100

    # random noise with the same size as the input image
    noise = np.random.randn(*image.shape) * std_dev
    # adding noise to image
    noisy_image = image + image * noise

    return np.clip(noisy_image, 0, 255).astype(np.uint8) #limit the pixel value of noise

def add_noise_to_frames(original_frames_folder, noise_folder, magnitude):

    os.makedirs(noise_folder, exist_ok=True)

    for filename in os.listdir(original_frames_folder):
        if filename.endswith(".jpg"):
            original_frame_path = os.path.join(original_frames_folder, filename)
            original_frame = cv2.imread(original_frame_path)

            noisy_frame = add_speckle_noise(original_frame, magnitude) # add pickle noise

            noisy_frame_filename = f"noise_{magnitude}_{filename}"
            cv2.imwrite(os.path.join(noise_folder, noisy_frame_filename), noisy_frame)

    print(f"{magnitude}% Speckle noise added to frames and saved in the '{noise_folder}' folder.")

original_frames_folder = "/content/frames"
noise_folder = "/content/noise_speckle_20"
magnitude = 20

add_noise_to_frames(original_frames_folder, noise_folder, magnitude)

noisy_frames_folder = "/content/noise_speckle_20"
image_prefix = "noise_20_frame"

display_images(noisy_frames_folder, image_prefix)

original_frames_folder = "/content/frames"
noise_folder = "/content/noise_speckle_40"
magnitude = 40

add_noise_to_frames(original_frames_folder, noise_folder, magnitude)

noisy_frames_folder = "/content/noise_speckle_40"
image_prefix = "noise_40_frame"

display_images(noisy_frames_folder, image_prefix)

original_frames_folder = "/content/frames"
noise_folder = "/content/noise_speckle_60"
magnitude = 60

add_noise_to_frames(original_frames_folder, noise_folder, magnitude)

noisy_frames_folder = "/content/noise_speckle_60"
image_prefix = "noise_60_frame"

display_images(noisy_frames_folder, image_prefix)

original_frames_folder = "/content/frames"
noise_folder = "/content/noise_speckle_80"
magnitude = 80

add_noise_to_frames(original_frames_folder, noise_folder, magnitude)

noisy_frames_folder = "/content/noise_speckle_80"
image_prefix = "noise_80_frame"

display_images(noisy_frames_folder, image_prefix)

"""# 4.2 Effect on POD Modes

# POD for Gaussian added noise

**POD for 20% noised image**
"""

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image for 20% noise')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

folder_path = "/content/noise_20"

images = load_and_preprocess_images(folder_path)

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Gaussian 20% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Energy contribution for 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)

for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD for 40% noised image**"""

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image for 40% noise')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

folder_path = "/content/noise_40"

images = load_and_preprocess_images(folder_path)

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Gaussian 40% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD for 60% noised image**"""

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image for 60% noise')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

folder_path = "/content/noise_60"

images = load_and_preprocess_images(folder_path)

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Gaussian 60% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD for 80% noised image**"""

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image of 80% noise')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

folder_path = "/content/noise_80"

images = load_and_preprocess_images(folder_path)

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Gaussian 80% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""# POD for Speckle added noise

**POD for 20% Speckle noise **
"""

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image of 20% noise')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

folder_path = "/content/noise_speckle_20"

images = load_and_preprocess_images(folder_path)

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Speckle 20% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD for 40% Speckle noise **"""

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image of 40% noise')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

folder_path = "/content/noise_speckle_40"

images = load_and_preprocess_images(folder_path)

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"speckle 40% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD for 60% Speckle noise **"""

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image of 60% noise')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

folder_path = "/content/noise_speckle_60"

images = load_and_preprocess_images(folder_path)

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Speckle 60% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD for 80% Speckle noise **"""

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image of 80% noise')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

folder_path = "/content/noise_speckle_80"

images = load_and_preprocess_images(folder_path)

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Speckle 80% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""# 5 Super-Resolving

# POD on denoised images using Gaussian Blur

**Function for denoising images using GaussianBlur and saving frames to new folder**
"""

def denoise_images(noisy_folder_path, output_folder_path, blur_kernel_size=(5, 5)):
    if not os.path.exists(output_folder_path):
        os.makedirs(output_folder_path)

    noisy_files = os.listdir(noisy_folder_path)

    # Process each noisy image
    for file_name in noisy_files:
        noisy_image_path = os.path.join(noisy_folder_path, file_name)
        noisy_image = cv2.imread(noisy_image_path)

        denoised_image = cv2.GaussianBlur(noisy_image, blur_kernel_size, 0)

        output_file_name = "denoised_" + file_name
        output_image_path = os.path.join(output_folder_path, output_file_name)
        cv2.imwrite(output_image_path, denoised_image)

output_folder_path = ["/content/denoised_images_20","/content/denoised_images_40", "/content/denoised_images_60","/content/denoised_images_80"]
noise_folder = [ "/content/noise_20",  "/content/noise_40",  "/content/noise_60",  "/content/noise_80"]

for i, folder_path in enumerate(output_folder_path):
  noisy_folder_path = f'{noise_folder[i]}'
  # print(noisy_folder_path)
  output_folder_path = folder_path
  denoise_images(noisy_folder_path, output_folder_path)
  print("Images denoised for " + noise_folder[i])

"""**POD for denoised images with 20% gaussian noise**"""

folder_path = "/content/denoised_images_20"

images = load_and_preprocess_images(folder_path)

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Denoised 20% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD for denoised images with 40% gaussian noise**"""

folder_path = "/content/denoised_images_40"

images = load_and_preprocess_images(folder_path)

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Denoised 40% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD for denoised images with 60% gaussian noise**"""

folder_path = "/content/denoised_images_60"

images = load_and_preprocess_images(folder_path)

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Denoised 60% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD for denoised images with 80% gaussian noise**"""

folder_path = "/content/denoised_images_80"

images = load_and_preprocess_images(folder_path)

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Denoised 80% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""# POD on noise removed images using NLM method

**Function for NLM noise removing technique**
"""

def denoise_image_nlm(input_image_path, output_image_path, h=10, hColor=10, templateWindowSize=7, searchWindowSize=21):
    image = cv2.imread(input_image_path)

    # NLM works on gray images
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    denoised_image = cv2.fastNlMeansDenoising(gray_image, None, h, templateWindowSize, searchWindowSize)

    cv2.imwrite(output_image_path, denoised_image)

"""**Noise removed on 20% noisy images using NLM**"""

input_folder = "/content/noise_20"
output_folder = "denoised_images_NLM_20"

os.makedirs(output_folder, exist_ok=True)

for filename in os.listdir(input_folder):
    if filename.endswith(".jpg"):
        input_image_path = os.path.join(input_folder, filename)
        output_image_path = os.path.join(output_folder, filename)
        denoise_image_nlm(input_image_path, output_image_path)

"""**Noise removed on 40% noisy images using NLM**"""

input_folder = "/content/noise_40"
output_folder = "denoised_images_NLM_40"

os.makedirs(output_folder, exist_ok=True)

for filename in os.listdir(input_folder):
    if filename.endswith(".jpg"):
        input_image_path = os.path.join(input_folder, filename)
        output_image_path = os.path.join(output_folder, filename)
        denoise_image_nlm(input_image_path, output_image_path)

"""**Noise removed on 60% noisy images using NLM**"""

input_folder = "/content/noise_60"
output_folder = "denoised_images_NLM_60"

os.makedirs(output_folder, exist_ok=True)

for filename in os.listdir(input_folder):
    if filename.endswith(".jpg"):
        input_image_path = os.path.join(input_folder, filename)
        output_image_path = os.path.join(output_folder, filename)
        denoise_image_nlm(input_image_path, output_image_path)

"""**Noise removed on 80% noisy images using NLM**"""

input_folder = "/content/noise_80"
output_folder = "denoised_images_NLM_80"

os.makedirs(output_folder, exist_ok=True)

for filename in os.listdir(input_folder):
    if filename.endswith(".jpg"):
        input_image_path = os.path.join(input_folder, filename)
        output_image_path = os.path.join(output_folder, filename)
        denoise_image_nlm(input_image_path, output_image_path)

"""**POD on 20% noise removed using NLM**"""

folder_path = "/content/denoised_images_NLM_20"

images = load_and_preprocess_images(folder_path)

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Denoised 80% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD on 40% noise removed using NLM**"""

folder_path = "/content/denoised_images_NLM_40"

images = load_and_preprocess_images(folder_path)

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Denoised 80% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD on 60% noise removed using NLM**"""

folder_path = "/content/denoised_images_NLM_60"

images = load_and_preprocess_images(folder_path)

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Denoised 80% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)

"""**POD on 80% noise removed using NLM**"""

folder_path = "/content/denoised_images_NLM_80"

images = load_and_preprocess_images(folder_path)

stacked_images = stack_images(images)

mean_image = np.mean(stacked_images, axis=0)

mean_image_reshaped = mean_image.reshape(images[0].shape)

plt.imshow(mean_image_reshaped)
plt.title('Mean Image')
plt.axis('off')
plt.show()

mean_subtracted_images = stacked_images - mean_image

U, S, Vt = np.linalg.svd(mean_subtracted_images, full_matrices=False)

num_modes = 10
dominant_modes = Vt[:num_modes, :]

temporal_coefficients = np.dot(dominant_modes, mean_subtracted_images.T)

reconstructed_images = np.dot(temporal_coefficients.T, dominant_modes) + mean_image

k_threshold = plot_cumulative_variance_ratio(S)

U_reduced = U[:, :k_threshold]
S_reduced = np.diag(S[:k_threshold])
Vt_reduced = Vt[:k_threshold, :]
reconstructed_images = U_reduced @ S_reduced @ Vt_reduced + mean_image

plt.figure(figsize=(15, 6))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(reconstructed_images[i].reshape(images[0].shape), cmap=None)
    plt.title(f"Denoised 80% Top Mode {i+1}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Total Energy of all modes
total_energy = np.sum(S[:k_threshold] ** 2)

# Total Energy of 10 modes
total_energy_top_10_modes = np.sum(S[:10] ** 2)

# % Contribution by 10 modes in total energy
percentage_energy_top_10_modes = (total_energy_top_10_modes / total_energy) * 100
print(f"Total energy: {total_energy}")
print(f"Sum of top 10 singular values: {total_energy_top_10_modes}")
print(f"Percentage of total energy contribution by the top 10 modes: {percentage_energy_top_10_modes:.2f}%")

# Individual energy of 10 modes
energy_first_10_modes = (S[:10] ** 2)
total_energy = np.sum(S[:k_threshold] ** 2)


for i, energy in enumerate(energy_first_10_modes, start=1):
    print(f"Energy contribution of mode {i}: {(energy_first_10_modes[i-1]/total_energy)*100:.2f}%")

plot_energy_contribution_first_10_modes(energy_first_10_modes, total_energy)